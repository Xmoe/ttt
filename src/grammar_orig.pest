EOL = _{ NEWLINE+ | &EOI}
Space = _{ " " }

HeaderOpen = _{ "[" }
HeaderClose = _{ "]" }

// This is a match on ANYthing, that is not EOL and not HeaderClose, multiple times
TestCaseName = ${ (!HeaderClose ~ !EOL ~ ANY)+ }
TestCaseHeader = _{ HeaderOpen ~ TestCaseName ~ HeaderClose ~ EOL }

IdentifierLaunch = { "$" }
IdentifierStdin = { "<" }
IdentifierStdout = { ">" }
IdentifierRegex = { "r" }
IdentifierControlChar = { "^" }
IdentifierExitCode = { "?" }

// TODO: better categorising of Instructions

ProcessNumber = { ASCII_DIGIT }
InstructionIdentifier = { (IdentifierLaunch | IdentifierStdin | IdentifierStdout | IdentifierRegex | IdentifierExitCode) }

ControlChar = { ASCII ~ &EOL}
InstructionControlChar = { ProcessNumber? ~ IdentifierControlChar ~ Space ~ ControlChar ~ EOL}

ExitCode = { ASCII_DIGIT+ ~ &EOL}
InstructionExitCode = { ProcessNumber? ~ IdentifierExitCode ~ Space ~ ExitCode ~ EOL}

Payload = ${ (!NEWLINE ~ ANY)* ~ &EOL }
InstructionWithPayload = { ProcessNumber? ~ InstructionIdentifier ~ Space ~ Payload ~ EOL}


Instructions = _{ (InstructionWithPayload | InstructionControlChar | InstructionExitCode)+ }

TestCase = { TestCaseHeader ~ Instructions }

COMMENT = _{ ("#" ~ (!NEWLINE ~ ANY)* ~ EOL) }

// It's important to add SOI and EOI to tell the parser to validate the whole input.
// Otherwise it may silently fail somewhere in the middle when it encounters and invalid input
TestSuite = { SOI ~ (NEWLINE|COMMENT)* ~ TestCase* ~ EOL}