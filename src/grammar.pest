EOL = _{ NEWLINE+ | &EOI}
Space = _{ " " }

HeaderOpen = _{ "[" }
HeaderClose = _{ "]" }

// This is a match on ANYthing, that is not EOL and not HeaderClose, multiple times
TestCaseName = ${ (!HeaderClose ~ !EOL ~ ANY)+ }
TestCaseHeader = _{ HeaderOpen ~ TestCaseName ~ HeaderClose ~ EOL }

ProcessNumber = { ASCII_DIGIT }
Payload = ${ (!NEWLINE ~ ANY)* ~ &EOL }

IdentifierLaunch = { "$" }
IdentifierStdin = { "<" }
IdentifierStdout = { ">" }
IdentifierRegex = { "r" }
IdentifierControlChar = { "^" }
IdentifierExitCode = { "?" }

// TODO: better categorising of Instructions

InstructionIdentifier = { (IdentifierLaunch | IdentifierStdin | IdentifierStdout | IdentifierRegex | IdentifierControlChar | IdentifierExitCode) }

Instruction = { ProcessNumber? ~ InstructionIdentifier ~ Space ~ Payload ~ EOL}

TestCase = { TestCaseHeader ~ Instruction+ }

COMMENT = _{ ("#" ~ (!NEWLINE ~ ANY)* ~ EOL) }

// It's important to add SOI and EOI to tell the parser to validate the whole input.
// Otherwise it may silently fail somewhere in the middle when it encounters and invalid input
TestSuite = { SOI ~ (NEWLINE|COMMENT)* ~ TestCase* ~ EOL}